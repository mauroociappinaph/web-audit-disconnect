export class VulnerabilityScanner {
  constructor() {
    this.vulnerabilityDatabases = {
      npm: 'https://registry.npmjs.org/',
      packagist: 'https://packagist.org/packages/',
      maven: 'https://search.maven.org/'
    };

    this.riskLevels = {
      CRITICAL: { score: 9.0, color: '#dc2626', description: 'Vulnerabilidad crítica que permite ejecución remota de código' },
      HIGH: { score: 7.0, color: '#ea580c', description: 'Vulnerabilidad de alto riesgo que afecta integridad o confidencialidad' },
      MEDIUM: { score: 5.0, color: '#d97706', description: 'Vulnerabilidad moderada con impacto limitado' },
      LOW: { score: 3.0, color: '#65a30d', description: 'Vulnerabilidad de bajo riesgo o informational' }
    };

    this.commonVulnerabilities = {
      'jquery': {
        '1.x': { risk: 'HIGH', cve: 'CVE-2019-11358', description: 'XSS vulnerability in jQuery < 3.4.0' },
        '2.x': { risk: 'HIGH', cve: 'CVE-2019-11358', description: 'XSS vulnerability in jQuery < 3.4.0' }
      },
      'bootstrap': {
        '3.x': { risk: 'MEDIUM', cve: 'CVE-2018-14041', description: 'XSS vulnerability in Bootstrap < 4.0.0' }
      },
      'lodash': {
        '4.17.10': { risk: 'CRITICAL', cve: 'CVE-2019-10744', description: 'Prototype pollution vulnerability' }
      },
      'axios': {
        '0.18.x': { risk: 'HIGH', cve: 'CVE-2019-10742', description: 'Server-side request forgery vulnerability' }
      }
    };
  }

  async scanForVulnerabilities(auditResults) {
    const vulnerabilities = {
      detected: [],
      summary: {
        total: 0,
        critical: 0,
        high: 0,
        medium: 0,
        low: 0
      },
      riskScore: 0,
      recommendations: []
    };

    // Escanear tecnologías detectadas
    const technologies = auditResults.technologies || {};

    // Escanear JavaScript libraries
    if (technologies.javascript) {
      const jsVulns = await this.scanJavaScriptLibraries(technologies.javascript);
      vulnerabilities.detected.push(...jsVulns);
    }

    // Escanear frameworks
    if (technologies.framework) {
      const frameworkVulns = await this.scanFrameworks(technologies.framework);
      vulnerabilities.detected.push(...frameworkVulns);
    }

    // Escanear CMS si existe
    if (technologies.cms) {
      const cmsVulns = await this.scanCMS(technologies.cms, auditResults.pageHTML);
      vulnerabilities.detected.push(...cmsVulns);
    }

    // Escanear headers de seguridad
    const headerVulns = this.scanSecurityHeaders(auditResults.responseHeaders);
    vulnerabilities.detected.push(...headerVulns);

    // Calcular resumen
    vulnerabilities.summary = this.calculateSummary(vulnerabilities.detected);
    vulnerabilities.riskScore = this.calculateRiskScore(vulnerabilities.detected);
    vulnerabilities.recommendations = this.generateRecommendations(vulnerabilities.detected);

    return vulnerabilities;
  }

  async scanJavaScriptLibraries(jsLibraries) {
    const vulnerabilities = [];

    // Escanear cada librería detectada
    for (const lib of jsLibraries) {
      const libVulns = this.checkLibraryVulnerabilities(lib.name, lib.version);
      vulnerabilities.push(...libVulns);
    }

    // Escanear por librerías comunes no detectadas pero potencialmente presentes
    const commonLibs = await this.detectCommonLibraries();
    for (const lib of commonLibs) {
      const libVulns = this.checkLibraryVulnerabilities(lib.name, lib.version);
      vulnerabilities.push(...libVulns);
    }

    return vulnerabilities;
  }

  checkLibraryVulnerabilities(libraryName, version) {
    const vulnerabilities = [];

    // Verificar en base de datos de vulnerabilidades conocidas
    const libKey = libraryName.toLowerCase();
    if (this.commonVulnerabilities[libKey]) {
      const libVulns = this.commonVulnerabilities[libKey];

      // Verificar si la versión es vulnerable
      for (const [vulnVersion, vulnData] of Object.entries(libVulns)) {
        if (this.isVersionVulnerable(version, vulnVersion)) {
          vulnerabilities.push({
            library: libraryName,
            version: version,
            vulnerability: vulnData.cve,
            risk: vulnData.risk,
            description: vulnData.description,
            impact: this.getVulnerabilityImpact(vulnData.risk),
            remediation: this.getRemediationAdvice(libraryName, vulnData.risk),
            cvss: this.riskLevels[vulnData.risk].score,
            source: 'known-vulnerabilities-db'
          });
        }
      }
    }

    // Verificar versiones desactualizadas
    if (this.isOutdatedVersion(libraryName, version)) {
      vulnerabilities.push({
        library: libraryName,
        version: version,
        vulnerability: 'OUTDATED_VERSION',
        risk: 'MEDIUM',
        description: `Versión ${version} está desactualizada y puede contener vulnerabilidades conocidas`,
        impact: 'Riesgo potencial de seguridad y falta de soporte',
        remediation: `Actualizar ${libraryName} a la versión más reciente`,
        cvss: 5.0,
        source: 'version-check'
      });
    }

    return vulnerabilities;
  }

  isVersionVulnerable(currentVersion, vulnerablePattern) {
    if (!currentVersion) return false;

    // Soporte básico de patrones de versión
    if (vulnerablePattern.includes('x')) {
      // Para patrones como "1.x", "2.x"
      const majorVersion = vulnerablePattern.split('.')[0];
      return currentVersion.startsWith(majorVersion);
    }

    // Comparación exacta
    return currentVersion === vulnerablePattern;
  }

  isOutdatedVersion(libraryName, version) {
    if (!version) return false;

    const outdatedVersions = {
      'jquery': '3.5.0',
      'bootstrap': '4.0.0',
      'lodash': '4.17.11',
      'axios': '0.21.0',
      'vue': '2.6.0',
      'react': '16.8.0',
      'angular': '1.8.0'
    };

    const libKey = libraryName.toLowerCase();
    if (outdatedVersions[libKey]) {
      return this.compareVersions(version, outdatedVersions[libKey]) < 0;
    }

    return false;
  }

  compareVersions(version1, version2) {
    const v1Parts = version1.split('.').map(Number);
    const v2Parts = version2.split('.').map(Number);

    for (let i = 0; i < Math.max(v1Parts.length, v2Parts.length); i++) {
      const v1Part = v1Parts[i] || 0;
      const v2Part = v2Parts[i] || 0;

      if (v1Part > v2Part) return 1;
      if (v1Part < v2Part) return -1;
    }

    return 0;
  }

  async detectCommonLibraries() {
    // En una implementación real, esto haría requests para detectar librerías
    // Por ahora, devolver un array vacío
    return [];
  }

  async scanFrameworks(frameworks) {
    const vulnerabilities = [];

    // Verificar que frameworks sea un array válido
    if (!Array.isArray(frameworks)) {
      return vulnerabilities;
    }

    for (const framework of frameworks) {
      // Verificar que framework tenga las propiedades necesarias
      if (!framework || typeof framework !== 'object') {
        continue;
      }

      const frameworkName = framework.name || '';
      const frameworkVersion = framework.version || '';

      // Verificar frameworks conocidos con vulnerabilidades
      if (frameworkName.toLowerCase() === 'wordpress' && frameworkVersion) {
        if (this.compareVersions(frameworkVersion, '5.0') < 0) {
          vulnerabilities.push({
            library: 'WordPress',
            version: frameworkVersion,
            vulnerability: 'OUTDATED_CMS',
            risk: 'HIGH',
            description: 'Versión antigua de WordPress con múltiples vulnerabilidades conocidas',
            impact: 'Riesgo alto de compromiso del sitio',
            remediation: 'Actualizar WordPress a la versión más reciente',
            cvss: 8.0,
            source: 'cms-security'
          });
        }
      }

      // Verificar otros frameworks comunes
      const frameworkChecks = {
        'drupal': { minVersion: '9.0', risk: 'HIGH' },
        'joomla': { minVersion: '4.0', risk: 'HIGH' },
        'magento': { minVersion: '2.4', risk: 'MEDIUM' }
      };

      const fwKey = frameworkName.toLowerCase();
      if (frameworkChecks[fwKey] && frameworkVersion) {
        const check = frameworkChecks[fwKey];
        if (this.compareVersions(frameworkVersion, check.minVersion) < 0) {
          vulnerabilities.push({
            library: frameworkName,
            version: frameworkVersion,
            vulnerability: 'OUTDATED_FRAMEWORK',
            risk: check.risk,
            description: `Versión antigua de ${frameworkName} con vulnerabilidades conocidas`,
            impact: `Riesgo ${check.risk.toLowerCase()} de seguridad`,
            remediation: `Actualizar ${frameworkName} a la versión ${check.minVersion} o superior`,
            cvss: this.riskLevels[check.risk].score,
            source: 'framework-security'
          });
        }
      }
    }

    return vulnerabilities;
  }

  async scanCMS(cms, pageHTML) {
    const vulnerabilities = [];

    // Escanear por plugins/temas vulnerables en WordPress
    if (cms.name && cms.name.toLowerCase().includes('wordpress')) {
      const wpVulns = await this.scanWordPressPlugins(pageHTML);
      vulnerabilities.push(...wpVulns);
    }

    return vulnerabilities;
  }

  async scanWordPressPlugins(pageHTML) {
    const vulnerabilities = [];

    // Plugins comunes con vulnerabilidades conocidas
    const vulnerablePlugins = {
      'wp-super-cache': { risk: 'MEDIUM', description: 'Caching plugin con vulnerabilidades conocidas' },
      'contact-form-7': { versions: ['4.x'], risk: 'LOW', description: 'Versiones antiguas con XSS' },
      'woocommerce': { versions: ['3.x'], risk: 'MEDIUM', description: 'Versiones antiguas con SQL injection' }
    };

    // En una implementación real, esto analizaría el HTML para detectar plugins
    // Por ahora, devolver detecciones simuladas basadas en patrones comunes

    return vulnerabilities;
  }

  scanSecurityHeaders(responseHeaders = {}) {
    const vulnerabilities = [];
    const headers = responseHeaders;

    // Verificar Content Security Policy
    if (!headers['content-security-policy'] && !headers['x-content-security-policy']) {
      vulnerabilities.push({
        library: 'Security Headers',
        version: 'N/A',
        vulnerability: 'MISSING_CSP',
        risk: 'MEDIUM',
        description: 'Falta Content Security Policy (CSP) que protege contra XSS',
        impact: 'Vulnerabilidad a ataques XSS y inyección de código',
        remediation: 'Implementar CSP header con políticas restrictivas',
        cvss: 6.0,
        source: 'security-headers'
      });
    }

    // Verificar HSTS
    if (!headers['strict-transport-security']) {
      vulnerabilities.push({
        library: 'Security Headers',
        version: 'N/A',
        vulnerability: 'MISSING_HSTS',
        risk: 'MEDIUM',
        description: 'Falta Strict Transport Security que previene ataques SSL stripping',
        impact: 'Posible downgrade a HTTP no seguro',
        remediation: 'Implementar HSTS header con max-age apropiado',
        cvss: 5.0,
        source: 'security-headers'
      });
    }

    // Verificar X-Frame-Options
    if (!headers['x-frame-options']) {
      vulnerabilities.push({
        library: 'Security Headers',
        version: 'N/A',
        vulnerability: 'MISSING_X_FRAME_OPTIONS',
        risk: 'LOW',
        description: 'Falta X-Frame-Options que previene clickjacking',
        impact: 'Vulnerabilidad a ataques de clickjacking',
        remediation: 'Implementar X-Frame-Options: SAMEORIGIN o DENY',
        cvss: 4.0,
        source: 'security-headers'
      });
    }

    // Verificar X-Content-Type-Options
    if (!headers['x-content-type-options']) {
      vulnerabilities.push({
        library: 'Security Headers',
        version: 'N/A',
        vulnerability: 'MISSING_X_CONTENT_TYPE',
        risk: 'LOW',
        description: 'Falta X-Content-Type-Options que previene MIME sniffing',
        impact: 'Posible ejecución de código malicioso',
        remediation: 'Implementar X-Content-Type-Options: nosniff',
        cvss: 3.0,
        source: 'security-headers'
      });
    }

    return vulnerabilities;
  }

  getVulnerabilityImpact(risk) {
    return this.riskLevels[risk]?.description || 'Impacto no determinado';
  }

  getRemediationAdvice(library, risk) {
    const advice = {
      CRITICAL: `Actualizar ${library} inmediatamente y aplicar parche de seguridad`,
      HIGH: `Actualizar ${library} lo antes posible y monitorear por exploits`,
      MEDIUM: `Planificar actualización de ${library} en el próximo ciclo de mantenimiento`,
      LOW: `Considerar actualización de ${library} cuando sea conveniente`
    };

    return advice[risk] || `Revisar y actualizar ${library} según sea necesario`;
  }

  calculateSummary(vulnerabilities) {
    const summary = {
      total: vulnerabilities.length,
      critical: 0,
      high: 0,
      medium: 0,
      low: 0
    };

    vulnerabilities.forEach(vuln => {
      const risk = vuln.risk.toLowerCase();
      if (summary[risk] !== undefined) {
        summary[risk]++;
      }
    });

    return summary;
  }

  calculateRiskScore(vulnerabilities) {
    if (vulnerabilities.length === 0) return 0;

    const totalScore = vulnerabilities.reduce((sum, vuln) => {
      return sum + (this.riskLevels[vuln.risk]?.score || 0);
    }, 0);

    // Normalizar a escala 0-100
    const maxPossibleScore = vulnerabilities.length * 9.0; // Máximo CVSS
    const normalizedScore = (totalScore / maxPossibleScore) * 100;

    return Math.min(100, Math.round(normalizedScore));
  }

  generateRecommendations(vulnerabilities) {
    const recommendations = [];

    if (vulnerabilities.length === 0) {
      return [{
        priority: 'LOW',
        category: 'Security',
        issue: 'No se detectaron vulnerabilidades críticas',
        action: 'Mantener actualizadas las dependencias y monitorear nuevas vulnerabilidades'
      }];
    }

    // Recomendaciones basadas en severidad
    const criticalCount = vulnerabilities.filter(v => v.risk === 'CRITICAL').length;
    const highCount = vulnerabilities.filter(v => v.risk === 'HIGH').length;

    if (criticalCount > 0) {
      recommendations.push({
        priority: 'CRITICAL',
        category: 'Security',
        issue: `${criticalCount} vulnerabilidades críticas detectadas`,
        action: 'Aplicar parches inmediatamente - riesgo de compromiso del sistema'
      });
    }

    if (highCount > 0) {
      recommendations.push({
        priority: 'HIGH',
        category: 'Security',
        issue: `${highCount} vulnerabilidades de alto riesgo`,
        action: 'Actualizar dependencias vulnerables en las próximas 24-48 horas'
      });
    }

    // Recomendación general de seguridad
    recommendations.push({
      priority: 'MEDIUM',
      category: 'Security',
      issue: 'Implementar monitoreo continuo de vulnerabilidades',
      action: 'Configurar herramientas como Snyk, Dependabot o npm audit'
    });

    return recommendations;
  }
}

export default VulnerabilityScanner;
