export class VulnerabilityScanner {
  constructor() {
    this.vulnerabilityDatabases = {
      npm: 'https://registry.npmjs.org/',
      packagist: 'https://packagist.org/packages/',
      maven: 'https://search.maven.org/',
      nvd: 'https://services.nvd.nist.gov/rest/json/cves/1.0',
      osv: 'https://api.osv.dev/v1/query'
    };

    this.riskLevels = {
      CRITICAL: { score: 9.0, color: '#dc2626', description: 'Vulnerabilidad crítica que permite ejecución remota de código' },
      HIGH: { score: 7.0, color: '#ea580c', description: 'Vulnerabilidad de alto riesgo que afecta integridad o confidencialidad' },
      MEDIUM: { score: 5.0, color: '#d97706', description: 'Vulnerabilidad moderada con impacto limitado' },
      LOW: { score: 3.0, color: '#65a30d', description: 'Vulnerabilidad de bajo riesgo o informational' }
    };

    this.dependencyFiles = [
      'package.json',
      'package-lock.json',
      'yarn.lock',
      'composer.json',
      'composer.lock',
      'requirements.txt',
      'Pipfile',
      'Pipfile.lock',
      'Gemfile',
      'Gemfile.lock'
    ];

    this.commonVulnerabilities = {
      'jquery': {
        '1.x': { risk: 'HIGH', cve: 'CVE-2019-11358', description: 'XSS vulnerability in jQuery < 3.4.0' },
        '2.x': { risk: 'HIGH', cve: 'CVE-2019-11358', description: 'XSS vulnerability in jQuery < 3.4.0' }
      },
      'bootstrap': {
        '3.x': { risk: 'MEDIUM', cve: 'CVE-2018-14041', description: 'XSS vulnerability in Bootstrap < 4.0.0' }
      },
      'lodash': {
        '4.17.10': { risk: 'CRITICAL', cve: 'CVE-2019-10744', description: 'Prototype pollution vulnerability' }
      },
      'axios': {
        '0.18.x': { risk: 'HIGH', cve: 'CVE-2019-10742', description: 'Server-side request forgery vulnerability' }
      }
    };
  }

  async scanForVulnerabilities(auditResults) {
    const vulnerabilities = {
      detected: [],
      dependencyScan: {
        scanned: false,
        filesFound: [],
        dependencies: [],
        vulnerabilities: []
      },
      summary: {
        total: 0,
        critical: 0,
        high: 0,
        medium: 0,
        low: 0
      },
      riskScore: 0,
      recommendations: []
    };

    // Intentar escanear archivos de dependencias reales
    try {
      const dependencyScan = await this.scanDependencyFiles(auditResults.url);
      vulnerabilities.dependencyScan = dependencyScan;
      vulnerabilities.detected.push(...dependencyScan.vulnerabilities);
    } catch (error) {
      console.warn('No se pudieron escanear archivos de dependencias:', error.message);
    }

    // Escanear tecnologías detectadas
    const technologies = auditResults.technologies || {};

    // Escanear JavaScript libraries
    if (technologies.javascript) {
      const jsVulns = await this.scanJavaScriptLibraries(technologies.javascript);
      vulnerabilities.detected.push(...jsVulns);
    }

    // Escanear frameworks
    if (technologies.framework) {
      const frameworkVulns = await this.scanFrameworks(technologies.framework);
      vulnerabilities.detected.push(...frameworkVulns);
    }

    // Escanear CMS si existe
    if (technologies.cms) {
      const cmsVulns = await this.scanCMS(technologies.cms, auditResults.pageHTML);
      vulnerabilities.detected.push(...cmsVulns);
    }

    // Escanear headers de seguridad
    const headerVulns = this.scanSecurityHeaders(auditResults.responseHeaders);
    vulnerabilities.detected.push(...headerVulns);

    // Calcular resumen
    vulnerabilities.summary = this.calculateSummary(vulnerabilities.detected);
    vulnerabilities.riskScore = this.calculateRiskScore(vulnerabilities.detected);
    vulnerabilities.recommendations = this.generateRecommendations(vulnerabilities.detected);

    return vulnerabilities;
  }

  // ===== NUEVA FUNCIONALIDAD: ESCANEO COMPLETO DE DEPENDENCIAS =====

  async scanDependencyFiles(siteUrl) {
    const scanResult = {
      scanned: true,
      filesFound: [],
      dependencies: [],
      vulnerabilities: []
    };

    try {
      // Intentar acceder a archivos comunes de dependencias
      for (const fileName of this.dependencyFiles) {
        try {
          const fileUrl = this.constructFileUrl(siteUrl, fileName);
          const response = await this.fetchFile(fileUrl);

          if (response && response.data) {
            scanResult.filesFound.push(fileName);
            const fileVulns = await this.analyzeDependencyFile(fileName, response.data);
            scanResult.vulnerabilities.push(...fileVulns);

            // Extraer dependencias para reporte
            const deps = this.extractDependencies(fileName, response.data);
            scanResult.dependencies.push(...deps);
          }
        } catch (error) {
          // Archivo no encontrado o no accesible, continuar
          continue;
        }
      }
    } catch (error) {
      console.warn('Error durante el escaneo de dependencias:', error.message);
    }

    return scanResult;
  }

  constructFileUrl(siteUrl, fileName) {
    // Remover protocolo y www si existe
    let baseUrl = siteUrl.replace(/^https?:\/\//, '').replace(/^www\./, '');

    // Para archivos comunes, intentar rutas estándar
    const commonPaths = [
      `https://${baseUrl}/${fileName}`,
      `https://www.${baseUrl}/${fileName}`,
      `https://${baseUrl}/package.json`, // Algunos sitios exponen package.json
    ];

    return commonPaths[0]; // Usar la primera opción por defecto
  }

  async fetchFile(url) {
    const axios = (await import('axios')).default;
    try {
      const response = await axios.get(url, {
        timeout: 5000,
        headers: {
          'User-Agent': 'Mozilla/5.0 (compatible; SecurityScanner/1.0)'
        },
        validateStatus: (status) => status < 400
      });
      return response;
    } catch (error) {
      return null;
    }
  }

  async analyzeDependencyFile(fileName, fileContent) {
    const vulnerabilities = [];

    try {
      const data = JSON.parse(fileContent);

      if (fileName === 'package.json') {
        const deps = { ...data.dependencies, ...data.devDependencies };
        const packageVulns = await this.checkPackageDependencies(deps);
        vulnerabilities.push(...packageVulns);
      }

      if (fileName === 'composer.json') {
        const deps = { ...data.require, ...data['require-dev'] };
        const composerVulns = await this.checkComposerDependencies(deps);
        vulnerabilities.push(...composerVulns);
      }

      if (fileName === 'requirements.txt') {
        const pythonVulns = await this.checkPythonDependencies(fileContent);
        vulnerabilities.push(...pythonVulns);
      }

    } catch (error) {
      console.warn(`Error analizando ${fileName}:`, error.message);
    }

    return vulnerabilities;
  }

  extractDependencies(fileName, fileContent) {
    const dependencies = [];

    try {
      const data = JSON.parse(fileContent);

      if (fileName === 'package.json') {
        const deps = { ...data.dependencies, ...data.devDependencies };
        for (const [name, version] of Object.entries(deps)) {
          dependencies.push({
            name,
            version: version.replace(/[\^~]/g, ''),
            type: 'npm',
            file: fileName
          });
        }
      }

      if (fileName === 'composer.json') {
        const deps = { ...data.require, ...data['require-dev'] };
        for (const [name, version] of Object.entries(deps)) {
          dependencies.push({
            name,
            version: version.replace(/[\^~*]/g, ''),
            type: 'composer',
            file: fileName
          });
        }
      }

    } catch (error) {
      // Ignorar errores de parsing
    }

    return dependencies;
  }

  async checkPackageDependencies(dependencies) {
    const vulnerabilities = [];

    for (const [packageName, versionSpec] of Object.entries(dependencies)) {
      try {
        // Limpiar especificador de versión
        const cleanVersion = versionSpec.replace(/[\^~>=<]/g, '').split(' ')[0];

        // Verificar contra base de datos local
        const localVulns = this.checkLocalVulnerabilityDatabase(packageName, cleanVersion);
        vulnerabilities.push(...localVulns);

        // Verificar contra OSV (Open Source Vulnerabilities)
        const osvVulns = await this.checkOSVDatabase(packageName, cleanVersion);
        vulnerabilities.push(...osvVulns);

      } catch (error) {
        console.warn(`Error verificando ${packageName}:`, error.message);
      }
    }

    return vulnerabilities;
  }

  async checkComposerDependencies(dependencies) {
    const vulnerabilities = [];

    for (const [packageName, versionSpec] of Object.entries(dependencies)) {
      try {
        const cleanVersion = versionSpec.replace(/[\^~>=<]/g, '').split(' ')[0];

        // Verificar vulnerabilidades conocidas de PHP
        const phpVulns = this.checkPHPVulnerabilities(packageName, cleanVersion);
        vulnerabilities.push(...phpVulns);

      } catch (error) {
        console.warn(`Error verificando ${packageName}:`, error.message);
      }
    }

    return vulnerabilities;
  }

  async checkPythonDependencies(requirementsTxt) {
    const vulnerabilities = [];
    const lines = requirementsTxt.split('\n');

    for (const line of lines) {
      if (line.trim() && !line.startsWith('#')) {
        try {
          const match = line.match(/^([a-zA-Z0-9\-_.]+)([=<>~!]+)(.+)/);
          if (match) {
            const [, packageName, , version] = match;
            const pythonVulns = this.checkPythonVulnerabilities(packageName, version);
            vulnerabilities.push(...pythonVulns);
          }
        } catch (error) {
          // Ignorar líneas malformadas
        }
      }
    }

    return vulnerabilities;
  }

  checkLocalVulnerabilityDatabase(packageName, version) {
    const vulnerabilities = [];
    const libKey = packageName.toLowerCase();

    // Verificar base de datos local de vulnerabilidades conocidas
    if (this.commonVulnerabilities[libKey]) {
      const libVulns = this.commonVulnerabilities[libKey];

      for (const [vulnVersion, vulnData] of Object.entries(libVulns)) {
        if (this.isVersionVulnerable(version, vulnVersion)) {
          vulnerabilities.push({
            library: packageName,
            version: version,
            vulnerability: vulnData.cve,
            risk: vulnData.risk,
            description: vulnData.description,
            impact: this.getVulnerabilityImpact(vulnData.risk),
            remediation: this.getRemediationAdvice(packageName, vulnData.risk),
            cvss: this.riskLevels[vulnData.risk].score,
            source: 'local-vulnerability-db',
            ecosystem: 'npm'
          });
        }
      }
    }

    return vulnerabilities;
  }

  async checkOSVDatabase(packageName, version) {
    const vulnerabilities = [];

    try {
      const axios = (await import('axios')).default;
      const response = await axios.post(this.vulnerabilityDatabases.osv, {
        package: {
          name: packageName,
          ecosystem: 'npm'
        },
        version: version
      }, {
        timeout: 5000
      });

      if (response.data && response.data.vulns) {
        for (const vuln of response.data.vulns) {
          const risk = this.mapCVSSToRisk(vuln.database_specific?.severity || 'MEDIUM');

          vulnerabilities.push({
            library: packageName,
            version: version,
            vulnerability: vuln.id,
            risk: risk,
            description: vuln.summary || 'Vulnerabilidad detectada en base de datos OSV',
            impact: vuln.details || 'Impacto no especificado',
            remediation: `Actualizar ${packageName} a una versión segura`,
            cvss: this.riskLevels[risk].score,
            source: 'osv-database',
            ecosystem: 'npm'
          });
        }
      }
    } catch (error) {
      // OSV API no disponible, continuar sin errores
      console.warn('OSV API no disponible:', error.message);
    }

    return vulnerabilities;
  }

  checkPHPVulnerabilities(packageName, version) {
    const vulnerabilities = [];
    const knownVulnPHP = {
      'laravel/framework': {
        '8.x': { risk: 'MEDIUM', cve: 'CVE-2021-21263', description: 'Potential RCE in Laravel < 8.4.2' }
      },
      'symfony/symfony': {
        '4.x': { risk: 'HIGH', cve: 'CVE-2020-15094', description: 'Potential RCE in Symfony < 4.4.11' }
      }
    };

    const libKey = packageName.toLowerCase();
    if (knownVulnPHP[libKey]) {
      const libVulns = knownVulnPHP[libKey];

      for (const [vulnVersion, vulnData] of Object.entries(libVulns)) {
        if (this.isVersionVulnerable(version, vulnVersion)) {
          vulnerabilities.push({
            library: packageName,
            version: version,
            vulnerability: vulnData.cve,
            risk: vulnData.risk,
            description: vulnData.description,
            impact: this.getVulnerabilityImpact(vulnData.risk),
            remediation: this.getRemediationAdvice(packageName, vulnData.risk),
            cvss: this.riskLevels[vulnData.risk].score,
            source: 'php-vulnerability-db',
            ecosystem: 'composer'
          });
        }
      }
    }

    return vulnerabilities;
  }

  checkPythonVulnerabilities(packageName, version) {
    const vulnerabilities = [];
    const knownVulnPython = {
      'django': {
        '2.x': { risk: 'HIGH', cve: 'CVE-2020-7471', description: 'Potential SQL injection in Django < 2.2.10' }
      },
      'flask': {
        '1.x': { risk: 'MEDIUM', cve: 'CVE-2018-1000656', description: 'Potential RCE in Flask < 1.0' }
      }
    };

    const libKey = packageName.toLowerCase();
    if (knownVulnPython[libKey]) {
      const libVulns = knownVulnPython[libKey];

      for (const [vulnVersion, vulnData] of Object.entries(libVulns)) {
        if (this.isVersionVulnerable(version, vulnVersion)) {
          vulnerabilities.push({
            library: packageName,
            version: version,
            vulnerability: vulnData.cve,
            risk: vulnData.risk,
            description: vulnData.description,
            impact: this.getVulnerabilityImpact(vulnData.risk),
            remediation: this.getRemediationAdvice(packageName, vulnData.risk),
            cvss: this.riskLevels[vulnData.risk].score,
            source: 'python-vulnerability-db',
            ecosystem: 'pypi'
          });
        }
      }
    }

    return vulnerabilities;
  }

  mapCVSSToRisk(cvssScore) {
    if (cvssScore >= 9.0) return 'CRITICAL';
    if (cvssScore >= 7.0) return 'HIGH';
    if (cvssScore >= 4.0) return 'MEDIUM';
    return 'LOW';
  }

  async scanJavaScriptLibraries(jsLibraries) {
    const vulnerabilities = [];

    // Escanear cada librería detectada
    for (const lib of jsLibraries) {
      const libVulns = this.checkLibraryVulnerabilities(lib.name, lib.version);
      vulnerabilities.push(...libVulns);
    }

    // Escanear por librerías comunes no detectadas pero potencialmente presentes
    const commonLibs = await this.detectCommonLibraries();
    for (const lib of commonLibs) {
      const libVulns = this.checkLibraryVulnerabilities(lib.name, lib.version);
      vulnerabilities.push(...libVulns);
    }

    return vulnerabilities;
  }

  checkLibraryVulnerabilities(libraryName, version) {
    const vulnerabilities = [];

    // Verificar en base de datos de vulnerabilidades conocidas
    const libKey = libraryName.toLowerCase();
    if (this.commonVulnerabilities[libKey]) {
      const libVulns = this.commonVulnerabilities[libKey];

      // Verificar si la versión es vulnerable
      for (const [vulnVersion, vulnData] of Object.entries(libVulns)) {
        if (this.isVersionVulnerable(version, vulnVersion)) {
          vulnerabilities.push({
            library: libraryName,
            version: version,
            vulnerability: vulnData.cve,
            risk: vulnData.risk,
            description: vulnData.description,
            impact: this.getVulnerabilityImpact(vulnData.risk),
            remediation: this.getRemediationAdvice(libraryName, vulnData.risk),
            cvss: this.riskLevels[vulnData.risk].score,
            source: 'known-vulnerabilities-db'
          });
        }
      }
    }

    // Verificar versiones desactualizadas
    if (this.isOutdatedVersion(libraryName, version)) {
      vulnerabilities.push({
        library: libraryName,
        version: version,
        vulnerability: 'OUTDATED_VERSION',
        risk: 'MEDIUM',
        description: `Versión ${version} está desactualizada y puede contener vulnerabilidades conocidas`,
        impact: 'Riesgo potencial de seguridad y falta de soporte',
        remediation: `Actualizar ${libraryName} a la versión más reciente`,
        cvss: 5.0,
        source: 'version-check'
      });
    }

    return vulnerabilities;
  }

  isVersionVulnerable(currentVersion, vulnerablePattern) {
    if (!currentVersion) return false;

    // Soporte básico de patrones de versión
    if (vulnerablePattern.includes('x')) {
      // Para patrones como "1.x", "2.x"
      const majorVersion = vulnerablePattern.split('.')[0];
      return currentVersion.startsWith(majorVersion);
    }

    // Comparación exacta
    return currentVersion === vulnerablePattern;
  }

  isOutdatedVersion(libraryName, version) {
    if (!version) return false;

    const outdatedVersions = {
      'jquery': '3.5.0',
      'bootstrap': '4.0.0',
      'lodash': '4.17.11',
      'axios': '0.21.0',
      'vue': '2.6.0',
      'react': '16.8.0',
      'angular': '1.8.0'
    };

    const libKey = libraryName.toLowerCase();
    if (outdatedVersions[libKey]) {
      return this.compareVersions(version, outdatedVersions[libKey]) < 0;
    }

    return false;
  }

  compareVersions(version1, version2) {
    const v1Parts = version1.split('.').map(Number);
    const v2Parts = version2.split('.').map(Number);

    for (let i = 0; i < Math.max(v1Parts.length, v2Parts.length); i++) {
      const v1Part = v1Parts[i] || 0;
      const v2Part = v2Parts[i] || 0;

      if (v1Part > v2Part) return 1;
      if (v1Part < v2Part) return -1;
    }

    return 0;
  }

  async detectCommonLibraries() {
    // En una implementación real, esto haría requests para detectar librerías
    // Por ahora, devolver un array vacío
    return [];
  }

  async scanFrameworks(frameworks) {
    const vulnerabilities = [];

    // Verificar que frameworks sea un array válido
    if (!Array.isArray(frameworks)) {
      return vulnerabilities;
    }

    for (const framework of frameworks) {
      // Verificar que framework tenga las propiedades necesarias
      if (!framework || typeof framework !== 'object') {
        continue;
      }

      const frameworkName = framework.name || '';
      const frameworkVersion = framework.version || '';

      // Verificar frameworks conocidos con vulnerabilidades
      if (frameworkName.toLowerCase() === 'wordpress' && frameworkVersion) {
        if (this.compareVersions(frameworkVersion, '5.0') < 0) {
          vulnerabilities.push({
            library: 'WordPress',
            version: frameworkVersion,
            vulnerability: 'OUTDATED_CMS',
            risk: 'HIGH',
            description: 'Versión antigua de WordPress con múltiples vulnerabilidades conocidas',
            impact: 'Riesgo alto de compromiso del sitio',
            remediation: 'Actualizar WordPress a la versión más reciente',
            cvss: 8.0,
            source: 'cms-security'
          });
        }
      }

      // Verificar otros frameworks comunes
      const frameworkChecks = {
        'drupal': { minVersion: '9.0', risk: 'HIGH' },
        'joomla': { minVersion: '4.0', risk: 'HIGH' },
        'magento': { minVersion: '2.4', risk: 'MEDIUM' }
      };

      const fwKey = frameworkName.toLowerCase();
      if (frameworkChecks[fwKey] && frameworkVersion) {
        const check = frameworkChecks[fwKey];
        if (this.compareVersions(frameworkVersion, check.minVersion) < 0) {
          vulnerabilities.push({
            library: frameworkName,
            version: frameworkVersion,
            vulnerability: 'OUTDATED_FRAMEWORK',
            risk: check.risk,
            description: `Versión antigua de ${frameworkName} con vulnerabilidades conocidas`,
            impact: `Riesgo ${check.risk.toLowerCase()} de seguridad`,
            remediation: `Actualizar ${frameworkName} a la versión ${check.minVersion} o superior`,
            cvss: this.riskLevels[check.risk].score,
            source: 'framework-security'
          });
        }
      }
    }

    return vulnerabilities;
  }

  async scanCMS(cms, pageHTML) {
    const vulnerabilities = [];

    // Escanear por plugins/temas vulnerables en WordPress
    if (cms.name && cms.name.toLowerCase().includes('wordpress')) {
      const wpVulns = await this.scanWordPressPlugins(pageHTML);
      vulnerabilities.push(...wpVulns);
    }

    return vulnerabilities;
  }

  async scanWordPressPlugins(pageHTML) {
    const vulnerabilities = [];

    // Plugins comunes con vulnerabilidades conocidas
    const vulnerablePlugins = {
      'wp-super-cache': { risk: 'MEDIUM', description: 'Caching plugin con vulnerabilidades conocidas' },
      'contact-form-7': { versions: ['4.x'], risk: 'LOW', description: 'Versiones antiguas con XSS' },
      'woocommerce': { versions: ['3.x'], risk: 'MEDIUM', description: 'Versiones antiguas con SQL injection' }
    };

    // En una implementación real, esto analizaría el HTML para detectar plugins
    // Por ahora, devolver detecciones simuladas basadas en patrones comunes

    return vulnerabilities;
  }

  scanSecurityHeaders(responseHeaders = {}) {
    const vulnerabilities = [];
    const headers = responseHeaders;

    // Verificar Content Security Policy
    if (!headers['content-security-policy'] && !headers['x-content-security-policy']) {
      vulnerabilities.push({
        library: 'Security Headers',
        version: 'N/A',
        vulnerability: 'MISSING_CSP',
        risk: 'MEDIUM',
        description: 'Falta Content Security Policy (CSP) que protege contra XSS',
        impact: 'Vulnerabilidad a ataques XSS y inyección de código',
        remediation: 'Implementar CSP header con políticas restrictivas',
        cvss: 6.0,
        source: 'security-headers'
      });
    }

    // Verificar HSTS
    if (!headers['strict-transport-security']) {
      vulnerabilities.push({
        library: 'Security Headers',
        version: 'N/A',
        vulnerability: 'MISSING_HSTS',
        risk: 'MEDIUM',
        description: 'Falta Strict Transport Security que previene ataques SSL stripping',
        impact: 'Posible downgrade a HTTP no seguro',
        remediation: 'Implementar HSTS header con max-age apropiado',
        cvss: 5.0,
        source: 'security-headers'
      });
    }

    // Verificar X-Frame-Options
    if (!headers['x-frame-options']) {
      vulnerabilities.push({
        library: 'Security Headers',
        version: 'N/A',
        vulnerability: 'MISSING_X_FRAME_OPTIONS',
        risk: 'LOW',
        description: 'Falta X-Frame-Options que previene clickjacking',
        impact: 'Vulnerabilidad a ataques de clickjacking',
        remediation: 'Implementar X-Frame-Options: SAMEORIGIN o DENY',
        cvss: 4.0,
        source: 'security-headers'
      });
    }

    // Verificar X-Content-Type-Options
    if (!headers['x-content-type-options']) {
      vulnerabilities.push({
        library: 'Security Headers',
        version: 'N/A',
        vulnerability: 'MISSING_X_CONTENT_TYPE',
        risk: 'LOW',
        description: 'Falta X-Content-Type-Options que previene MIME sniffing',
        impact: 'Posible ejecución de código malicioso',
        remediation: 'Implementar X-Content-Type-Options: nosniff',
        cvss: 3.0,
        source: 'security-headers'
      });
    }

    return vulnerabilities;
  }

  getVulnerabilityImpact(risk) {
    return this.riskLevels[risk]?.description || 'Impacto no determinado';
  }

  getRemediationAdvice(library, risk) {
    const advice = {
      CRITICAL: `Actualizar ${library} inmediatamente y aplicar parche de seguridad`,
      HIGH: `Actualizar ${library} lo antes posible y monitorear por exploits`,
      MEDIUM: `Planificar actualización de ${library} en el próximo ciclo de mantenimiento`,
      LOW: `Considerar actualización de ${library} cuando sea conveniente`
    };

    return advice[risk] || `Revisar y actualizar ${library} según sea necesario`;
  }

  calculateSummary(vulnerabilities) {
    const summary = {
      total: vulnerabilities.length,
      critical: 0,
      high: 0,
      medium: 0,
      low: 0
    };

    vulnerabilities.forEach(vuln => {
      const risk = vuln.risk.toLowerCase();
      if (summary[risk] !== undefined) {
        summary[risk]++;
      }
    });

    return summary;
  }

  calculateRiskScore(vulnerabilities) {
    if (vulnerabilities.length === 0) return 0;

    const totalScore = vulnerabilities.reduce((sum, vuln) => {
      return sum + (this.riskLevels[vuln.risk]?.score || 0);
    }, 0);

    // Normalizar a escala 0-100
    const maxPossibleScore = vulnerabilities.length * 9.0; // Máximo CVSS
    const normalizedScore = (totalScore / maxPossibleScore) * 100;

    return Math.min(100, Math.round(normalizedScore));
  }

  generateRecommendations(vulnerabilities) {
    const recommendations = [];

    if (vulnerabilities.length === 0) {
      return [{
        priority: 'LOW',
        category: 'Security',
        issue: 'No se detectaron vulnerabilidades críticas',
        action: 'Mantener actualizadas las dependencias y monitorear nuevas vulnerabilidades'
      }];
    }

    // Recomendaciones basadas en severidad
    const criticalCount = vulnerabilities.filter(v => v.risk === 'CRITICAL').length;
    const highCount = vulnerabilities.filter(v => v.risk === 'HIGH').length;

    if (criticalCount > 0) {
      recommendations.push({
        priority: 'CRITICAL',
        category: 'Security',
        issue: `${criticalCount} vulnerabilidades críticas detectadas`,
        action: 'Aplicar parches inmediatamente - riesgo de compromiso del sistema'
      });
    }

    if (highCount > 0) {
      recommendations.push({
        priority: 'HIGH',
        category: 'Security',
        issue: `${highCount} vulnerabilidades de alto riesgo`,
        action: 'Actualizar dependencias vulnerables en las próximas 24-48 horas'
      });
    }

    // Recomendación general de seguridad
    recommendations.push({
      priority: 'MEDIUM',
      category: 'Security',
      issue: 'Implementar monitoreo continuo de vulnerabilidades',
      action: 'Configurar herramientas como Snyk, Dependabot o npm audit'
    });

    return recommendations;
  }
}

export default VulnerabilityScanner;
